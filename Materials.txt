
What is Javascript?

 The javascript is programming language.

Style of javascript

 standalone styles - inital java - before java 8 -  object oriented programming language
 hybrid styles - mixing many styles in one place.java 8  hybrid style language

javascript was designed as hybrid programming language.
 
javascript supports "functional style","Object based","Event driven" .

History of javascript programming:
..................................

1989 - Web Project was started    -------Sun created Java

1990 -  The first webserver,Browser was created

1994 - Netscap started

1995 - The first netscap navigator came to access web pages 

1996 - Netscap decided to put java inside webbrowser.

----Static web----- only hand coded html pages.

1996 - CREATED Dynamic web : how to work with databases
     - CGI - C,perl.
 J2EE- Servlets,JSP
 MS  - ASP
 OPEN SOURCE - PHP.

 Server side web : create html pages on fly by including data from databases.

Netscap decided to build client side web technoloy- once html is rendered into web browser
how to change that html onfly. 

Netscap decided to create a new programming language, who recurited Brendan Eich
,the programmer , asked to create new programming language for netscap navigator.

-Objective of Project

-It should be like java but it should not be java -light weight - scripting
-deadline is 10 days.

Time line:

1.javascript project started 1995

1.first name of the language was "Mocha"
2.language was renamed to "Live Script" -1996
3.language was renamed to "java Script" -1996



After language ready, which was submitted to standard body "ECMA international"

1996---1997 : JS 1.0 =>ES 1.0

1997- 1998 :  ES 2.0: It did not come

1999 :  ES 3

2007 : ES 4

2008 : ES 5

2012-2015 : ES 6

2016  ONWARDS : es 7,es 8, ......

//////////////////////////////////////////////////////////////////////////////////////////


...........................................................................................

Compilation,Execution, Runtime:
...............................

Javascript has no independant compiler like c++/java.

Runtime: 

 It is program, written in c / c++ , any language.
 Runtime is abstraction/communication layer between os and application programms.

Types of runtime:

1.embeded runtime
  embeded into another software
 eg:
   embeded game engines...
   browsers has lot of embbeded 

   webservers which running java code : tomcat

2.standalone runtime
  which is avaiable separatly
  JVM


Javascript runtime:
...................
 it is avaiable in both mode.

Embeded mode:
  js runtime is avaiable inside every browser.

chrome : V8 
firefox : Spider Monkey
ms : chakra .

standalone mode:
  node js, which has standalone js runtime.
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////

Does javascript code is compiled?

 Yes! , inside javascript runtime, which has embbeded compiler.
////////////////////////////////////////////////////////////////////////////////////////////

We are going to use v8:
  "V8 is Googleâ€™s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, 
////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////
Where is javascript ? what type of applications we can build using javascript?

1.javascript was created for browser only to process web documents.

Now a days  javascript is used every where.

1. javascript is in server side market : for build Webapps,webservices :Node.js
2. javascript is in mobility  : build mobile applications
3. javascript is in IOT : build any device specific applications.
/////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////

Java Script Programming language: ES 5 AND ES 6
...............................................

1.language fundamentals
2.functional programming
3.Object based programming
4.Browser specific features
   DOM,AJAX.

Node Js:
   Build Nonblocking IO applications 

/////////////////////////////////////////////////////////////////////////////////////////

language fundamentals:

1.type system
2.variables
3.values-literals
4.operators
5.conditional and iterators


Helloworld

index.js

how to run code?

1.via browser

index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=<device-width>, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script src="src/index.js"></script>
</body>
</html>

2.via node platform

$node src/index.js
///////////////////////////////////////////////////////////////////////////////////////////

Javascript is dynamic language:
 during runtime we can modify code.

Type system:

 How to represent data 

Strongly/Static typed languages

 The variable is verfied by the compiler during compile time

eg:
  int a =10;

  a ="hello" ; compiler will show error.

eg: c,c++,java,c#

Weakly/Dynamic typed languages


  The variable type is verifed by the runtime during execution

   def/var(keyword) variableName=value

 eg:
   var a =10;
   a="hello"
  it is perfectly valid

eg:
 js
/////////////////////////////////////////////////////////////////////////////////////////////

How to declare variables?

ES 5

var
Declares a variable, optionally initializing it to a value.

ES 6
let
Declares a block-scoped, local variable, optionally initializing it to a value.
const
Declares a block-scoped, read-only named constant.

this 
  keyword used to declare instance variables(objects)


syntax:

 keyword(var/let/const/this) variableName = value(literal)
 

//how to declare variable

var firstName="Subramanian";
console.log("First Name" + firstName);


literals : values based on it only the type of variable is identified during runtime.

literals types:

1.string
2.number
3.boolean
4.undefined
5.NaN
6.infinity
7.function
8.null
9.object

 var : is used in es 5
 let and const is used in es 6
 this : both version



Note: 
1.var,let,const all are same only but there are few differences, to be disucssed latter.
 var vs let and const.

2.In js ; is optional 


Point:

  if you are building javascript application based on es 6, recommandation is use "let and
const" always.

1.strings:

1.16 bit unicode charaters.

2.strings can be declared inside  "" or ''  or ``(back-tick) es 6 feature
   "" : inspired from java and c++
   '' : js specific notation.
  
3.string concatnation can be done
   +  and , and `foo ${variableName}`
//strings

var firstName = "Subramanian"
var lastName = 'Murugan';

console.log(" Name " + firstName + " " + lastName);
console.log(" Name ", firstName, " ", lastName);

//es 6 concatation syntax. `${variableName}` - interpolation

console.log(`Name ${firstName} ${lastName} `)

//Roles of `` notation : string concation,multi line string litreal.

var title = 'Game Portal'

var htmlDoc = "<html>" +
    "<head><title>" +
    title +
    "</title>" +
    "</head>" +
    "<body><h1>Sony Digital</h1>" +
    "</body></html>";
console.log(htmlDoc);

var newHtmlDoc = `
    <html>
      <head>
        <title>${title}</title>
    </head>
    <body><h1>Astro Gaming Site</h1>
    </body></html>
`;
console.log(newHtmlDoc);
//////////////////////////////////////////////////////////////////////////////////////////////

Numbers:

1.number size is 64 bit by default aka double.
2.It is IEEE 754 Standard.
//numbers

var qty = 10;
var price=1000000000000000000000000000;
console.log(`Qty ${qty}`);
console.log(`Price ${price}`)


Booleans:

1.represents true or false 
2.1 bit value.

//boolean

var isEnabled =true;
var isWorking=false;

console.log(`Enabled ${isEnabled}`)
console.log(`Isworking ${isWorking} `);



undefined:
..........
It is value, assigned to a variable, if no valid literal is assigned.


var firstName;
var price;
var qty;
console.log(`First Name ${firstName}`);
console.log(`price ${price} ${qty}`);

///////////////////////////////////////////////////////////////////////////////////////////

Related to Numbers:

1.NaN :Not a Number 

Not a Number but is number.
NaN represents error code.
NaN error code will come due to "numerical compuation failures".

Note:

 if you get NaN as out put, it is danger/toxic , it is runtime error, you need to fix.


When NaN will come?
 
//NaN use case 1; if you do numerical compuation against undefined

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)


Type conversion : string to number

types of Type conversion

1.implicit Type conversion
 js automatically converts string to number
2.explicit Type conversion
 js uses conversion utility apis to convert string to number.

//NAN

var qty; //undefined
var price = 1000;

var totalPrice = qty * price;
console.log(`Qty ${qty} price ${price} Total Price ${totalPrice}`)
//Type conversion

var count = "10"; // it string type but value is numerical value

//Type conversion happened here; implicit conversion
var totalCount = count * 10;
console.log(`Total Count ${totalCount}`);

//Type conversion using js built in api.
//double(64 bit) to 32 bit(integer)
var totalCounter = parseInt(count) * 10;
console.log(`Total Count ${totalCounter}`);
var totalCounterdouble = parseFloat(count,16) * 10;
console.log(`Total Count ${totalCounterdouble}`);


//Nan and type conversion
// here $100 is not numerical so during type conversion, error is thrown.
var stockValue = "$100";
var totalStock  = parseInt(stockValue) * 100;
console.log(`Total Stock ${totalStock}`);


2.infinity
div by 0


var price = 1000;
var avgPrice = price / 0;
//Avg Price Infinity
console.log(`Avg Price ${avgPrice}`);

////////////////////////////////////////////////////////////////////////////////////////////
Advanced booleans:
  
js supports booleans with value of true / false

In js every thing is true expect the following values.

Falsy Values:

1.boolean false
2.0
3.undefined
4.empty string "",''
5.NaN
6.null



//Advanced boolean

var firstName = "Subramaian";

if (firstName) {
    console.log("firstName found")
} else {
    console.log("firstName not found")
}
var lastName = "";

if (lastName) {
    console.log("lastName found")
} else {
    console.log("lastName not found")
}

var age = 18;

if (age) {
    console.log("age found")
} else {
    console.log("age not found")
}

var count = 0;

if (count) {
    console.log("count found")
} else {
    console.log("count not found")
}


var price;

if (price) {
    console.log("price found")
} else {
    console.log("price not found")
}


var totalPrice = price *100;

if (totalPrice) {
    console.log("totalPrice found")
} else {
    console.log("totalPrice not found")
}
/////////////////////////////////////////////////////////////////////////////////////////////

type of operator:
.................

1.returns type of variable in string format, in a smaller case

  "string","numbers"


//type of operator

var str = "hello";
var n = 100;
var u;
var b = true;
var notanumber = n * u;
var avg = 100 / 0;
//object ,null,function types to be discussed later.

console.log(`type of str ${typeof str}`)
console.log(`type of n ${typeof n}`)
console.log(`type of b ${typeof b}`)
console.log(`type of u ${typeof u}`)
console.log(`type of notanumber ${typeof notanumber}`)
console.log(`type of avg ${typeof avg}`)
///////////////////////////////////////////////////////////////////////////////////////////

Operators:

Assignment operators
Comparison operators
Arithmetic operators
Bitwise operators
Logical operators
String operators
Conditional (ternary) operator
Comma operator
Unary operators
Relational operators

///////////////////////////////////////////////////////////////////////////////////////////

Assignement

Assignment	x = y	   x = y

Addition assignment	x += y	x = x + y
Subtraction assignment	x -= y	x = x - y
Multiplication assignment	x *= y	x = x * y
Division assignment	x /= y	x = x / y
Remainder assignment	x %= y	x = x % y
Exponentiation assignment	x **= y	x = x ** y
Left shift assignment	x <<= y	x = x << y
Right shift assignment	x >>= y	x = x >> y
Unsigned right shift assignment	x >>>= y	x = x >>> y
Bitwise AND assignment	x &= y	x = x & y
Bitwise XOR assignment	x ^= y	x = x ^ y
Bitwise OR assignment	x |= y	x = x | y
Logical AND assignment	x &&= y	x && (x = y)
Logical OR assignment	x ||= y	x || (x = y)
Logical nullish assignment	x ??= y	x ?? (x = y)

//assignment operator

var x = 10;
var y = x;
console.log(`x ${x} y ${y}`);

var myvar = 10;
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)
//reassingment/ re initalization
myvar = "Hello"
console.log(`Myvar value is ${myvar} and its type is ${typeof myvar}`)

var a = 100;
var b = 100;
var c = a + b;
console.log(`C value is ${c}`)
var d = 10;
d = d + 1;
console.log(`d value is ${d}`)
d += 1
console.log(`d value is ${d}`)

///////////////////////////////////////////////////////////////////////////////////////////

Arthimetic Operators;
.....................

numerical operators
 +,-,*,/,%
 ++,--,
 ** - exponent

//arthimetic 

var x = 100;
var y = 100;
console.log(x + y)
console.log(x - y)
console.log(x * y)
console.log(x / y)
console.log(x % y)
console.log(x ** 2)

Bitwise operators and shift operators:
Note : not recommend to overuse in js, js need to convert 64 bit to 32 bit and starts operations.

Logical operators:
...................

Logical AND (&&)

expr1 && expr2	Returns expr1 if it can be converted to false; otherwise, returns expr2. Thus, when used with Boolean values, && returns true if both operands are true; otherwise, returns false.

Logical OR (||)	expr1 || expr2	Returns expr1 if it can be converted to true; otherwise, returns expr2. Thus, when used with Boolean values, || returns true if either operand is true; if both are false, returns false.

Logical NOT (!)	!expr	Returns false if its single operand that can be converted to true; otherwise, returns true.

Logical !! -  keeps the same value.

//logical operators
//
//|| or - based on boolean truth table

var isWorking = true;
var isEnabled = false;
var res = isWorking || isEnabled;
console.log(res);
//advanced or operator.

var name = "Subramaian";

/**
 * if first operand(name) is truthy, then result is first operand itself else
 * second operand
 */

var message = name || "Sorry";

console.log(message);

var price = 0;
var todayMinPrice = price || 10;

console.log(todayMinPrice);
///////////////////////////////////////////////////////////////////////////////
//And operator is opposit to or operator

var andRes = isWorking && isEnabled
console.log(andRes);

/**
 * if first operand(name) is truthy, then result is second operand  else
 * first operand
 */

message = name && "Sorry";
console.log(message);
todayMinPrice = price && 10;
console.log(todayMinPrice);
/////////////////////////////////////////////////////////////////////////////

//inverter !

var reached =true;
console.log(!reached)
var mycount =1000;
console.log(!mycount)

//dont invert !!
console.log(!!reached)
console.log(!!mycount)

///////////////////////////////////////////////////////////////////////////////////////

Conditional (ternary) operator
The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:

condition ? val1 : val2

condition would be truthy or falsy

//tenary operators

var isEnabled = true;

var res = isEnabled ? "Enabled" : "Disabled";
console.log(res)

var name;
var found = name ? "Found" : "Not Found";
console.log(found)
/////////////////////////////////////////////////////////////////////////////////////////

Comparsional operators:
......................

1. less than <
2. less than or equal <=
3. greater than >
4. greater than or equal >=
5. ==, === equal
6. !=,!==

//relational operators

var x = 100;
var y = 10;
console.log((x < y) ? "less" : "not less")
console.log((x > y) ? "great" : "not great")
// == 

console.log((x == y) ? "equal" : "not equal")
console.log((x === y) ? "equal" : "not equal")

var a = "10";
var b = 10;
//test only value
console.log((a == b) ? "equal" : "not equal")
//test type + value : recommended operator ===
console.log((a === b) ? "equal" : "not equal")

console.log((a != b) ? "equal" : "not equal")
console.log((a !== b) ? "equal" : "not equal")
/////////////////////////////////////////////////////////////////////////////////////////////

Advanced operators

1.typeof - to know the type of variable
2.new  -  to allocate memory ; object creational operator
3.instance of - to know the parent type
4. in -  used with collection iterators
5. "." - object access operators
6. [] -  used to represent arrays elements &&  used to access object properties
7.{} -  to represent block of statements
8. of -  used with for loop
/////////////////////////////////////////////////////////////////////////////////////////////

Conditional statments and Control Structures:
..............................................

1.Decision making:

 if
 if..else
 if..elseif
 if ..elseif..else
 switch...case

statements:
  break;
 
//if and else

var a = 100;
var result='';
if (a > 0) {
    result = 'positive';
} else {
    result = 'NOT positive';
}
console.log(result)

..if..else if
var x = 10;

if (x > 50) {
    console.log("X is greater than 50")

} else if (x > 5) {
    /* do something */
    console.log("X is greater than 5")
} else {
    /* do something */
    console.log("No match found")
}
.........................................................................................



switch (expression) {

  case value1:
    //Statements executed when the
    //result of expression matches value1
    [break;]
  case value2:
    //Statements executed when the
    //result of expression matches value2
    [break;]
  ...
  case valueN:
    //Statements executed when the
    //result of expression matches valueN
    [break;]
  [default:
    //Statements executed when none of
    //the values match the value of the expression
    [break;]]
}

var expr = 'Papayas';
switch (expr) {
    case 'Oranges':
        console.log('Oranges are $0.59 a pound.');
        break;
    case 'Mangoes':
    case 'Papayas':
        console.log('Mangoes and papayas are $2.79 a pound.');
        // expected output: "Mangoes and papayas are $2.79 a pound."
        break;
    default:
        console.log(`Sorry, we are out of ${expr}.`);
}

//////////////////////////////////////////////////////////////////////////////////////////

Iterators -  loops;

1.for
2.while
3.do..while
4.for..in
5.for..of

var str = '';

for (var i = 0; i < 9; i++) {
    str = str + i;
}

console.log(str);

var n = 0;

while (n < 10) {
    console.log(n)
    n++;
}

console.log(n);
// expected output

var result = '';
var i = 0;

do {
    i = i + 1;
    result = result + i;
} while (i < 5);

console.log(result);
// expected result: "12345"

/////////////////////////////////////////////////////////////////////////////////////////////

Functions:
..........

What is function?

 function is block, inside we can define the logic.

syntax :

function declaration

 function functionName(args) {

   //block of code
 }

function invocation.


//define basic functions

function sayHello() {
    //block of code
    console.log('hello javascript')
}
//function invocation.
sayHello();

////////////////////////////////////////////////////////////////////////
The function with logic:
function add() {
    var a = 10;
    var b = 20;
    var c = a + b;
    console.log(`The addition ${c}`)
}
add()
/////////////////////////////////////////////////////////////////////////////////////////////
//parameters and args:
.....................

-javascript is type less , so args can take any type of literal

//function args and parameters
//message is arg
function sayHello(message) {
    console.log(message);
}
//pass value is here parameter
sayHello('Hello');
sayHello(10)
sayHello(true)
sayHello()
sayHello(NaN)


function add(a, b) {
    var result = a + b;
    console.log(result)
}
add(10, 10);
add()
add("10", "20")
add("10", 10)
add(10)
add(8, 8, 10)

function multiply(a, b) {
    //default value initalization if variables having undefined 
    //this is es 5 style
    a = a || 0;
    b = b || 0;
    var res = a * b;
    console.log(res);
}
multiply(10, 10)
multiply()
//es 6 style of default value initalizaiton
//default args
function multiplyE6(a = 0, b = 0) {
    var res = a * b;
    console.log(res);
}
multiplyE6(18, 10)
multiplyE6()
/////////////////////////////////////////////////////////////////////////////
//what if i want to pass more parameters, i dont know in advance how many args 
//i pass
function logger() {
    //arguments : built in variable, holding all parameter values
    console.log(arguments) //es 5 syntax
}
logger('hello')
logger('hello', 'greet')
logger('hello', 'welldone', 'good', 'js')

//Rest Operator : ... es 6 syntax to replace "arguments"
function sum(...numbers) {
   console.log(numbers)
}
sum(1, 2, 4);
sum(1, 2, 3, 4, 5, 6, 7, 8)

//////////////////////////////////////////////////////////////////////////////////////////////

What(literal) can be passed as parameter?

All literals can be passed as parameter.
 -strings,numbers,boolean,undefined,function,null,object,nan,infinity.


functions types:

1.user defined functions
  eg ; sayHello,add,compute
2.global built in functions
   functions are defined by js language.
 parseInt,parseFloat,isNaN,eval,isFinite,encodeURI(),decodeURI...


function compute(res) {
    if (isNaN(res)) {
        console.log('SOrry computation is failed')
    } else {
        console.log(res);
    }
}
var x = 10;
var y = 20
compute(x * y)
x = "$10"
compute(x * y)

function findAvg(a, b) {
    var res = a / b;
    if (res === Infinity) {
        console.log('div by 0 ')
    } else {
        console.log(res);
    }
}
findAvg(10, 2)
findAvg(10, 0)
////////////////////////////////////////////////////////////////////////////////////////////

How to return values from the function?

function can return any literal
///function returns

///function returns

function sayHello() {
    return 'Hello';
}
console.log(sayHello())

function sayHai() {
    var message = 'hai'
    return message;
}
console.log(sayHai())

function sayGreet() {
    return;
}
console.log(sayGreet())

function add(a = 1, b = 1) {
    return a + b; //expression
}
console.log(add(1, 2))

function validate(username = 'root', password = 'root') {
    if (username === 'admin' && password === 'admin') {
        return true;
    }
    return;
}
validate() ? console.log('success') : console.log('failed')
validate('admin','admin') ? console.log('success') : console.log('failed')

////////////////////////////////////////////////////////////////////////////////////////////

How to implement recurssive functions?
fact

function factorial(n) {
    if ((n === 0) || (n === 1))
        return 1;
    else
        return (n * factorial(n - 1));
}
console.log(factorial(5))


//////////////////////////////////////////////////////////////////////////////////////////
function literal(value)

literals can be assigned to a variable

let a =10;

since function itself literal can be assigned to a variable

//higher order func: function as parameter.

const fetch = function (success, failure) {
    if (typeof success === 'function' && typeof failure === 'function') {
        let status = true
        if (status) {
            success('This is success response')
        } else {
            failure('This is error response')
        }
    } else {
        console.log('invalid type')
    }
}

fetch(function (response) {
    console.log(response)
}, function (err) {
    console.log(err)
})
fetch(100, 'afdfdffa')
..................................................................................
				es 6 funcition literals
				 (Arrow functions)



//es 5 function declaration syntax
let hello = function () {
    console.log('hello')
}
//es 6 function declaration syntax : arrow function 
/**
 * 1.the value of this would be different in arrow function 
 * 2.the simple way of writing code - declarative programming.
 */

hello()

hello = () => {
    console.log('hello')
}
hello()
//if function has only one line of body : we can remove {}
hello = () => console.log('hello')
hello()
//args and parameters in arrow func 
let add = (a = 0, b = 0) => {
    let c = a + b
    console.log(`c ${c}`)
}
add(10, 90)

//return only value 
add = (a = 0, b = 0) => {
    return a + b
}
console.log(`c ${add(10, 90)
    }`)
//return only value , if there is no more code : we can remove {} and return statement
add = (a = 0, b = 0) => a + b
console.log(`c ${add(10, 90)
    }`)

//function with single arg , no default,return the same : we can remove {},(),
let getValue = value => value
console.log(getValue(90))


//higher order function and arrow 

// const greet = function (callback) {
//     callback()
// }

const greet = callback => callback('hai')


// let hai = function (response) {
//     console.log(response)
// }

let hai = response => console.log(response)
greet(hai)
// greet(function(response){
//     console.log(response)
// })
greet(response => console.log(response))

const fetch = (success, failure) => {
    if (typeof success === 'function' && typeof failure === 'function') {
        let status = true
        if (status) {
            success('This is success response')
        } else {
            failure('This is error response')
        }
    } else {
        console.log('invalid type')
    }
}

fetch(response => console.log(response), err => console.log(err))

....................................................................................
			 Scope

1.function scope - local scope
2.global scope - script scope
3.object scope
4.module scope

scope means visiability of a variable,function,class,literals....

any thing is declared inside function, is not available outside function

local scope :
 local variables,arg variables,functions declaration......

//
function counter(b = 90) {
    let a = 10;
    console.log('counter')
    //function body  - variables,functions 
    //inner function 
    function inc() {
        console.log('inc')
    }
    inc()
    let dec = function () {
        console.log('dec')
    }
    dec()

}
counter()
//inc()
//console.log(a)
//console.log(b)

//CURRY function : function returns a func and its returns another function and so on .. 

function outer() {
    return function () {
        console.log('innerone')
        return function () {
            console.log('inner two')
            return function () {
                console.log('inner three')
            }
        }
    }
}
outer()()()()

// function makeCake(sugar) {
//     return function (milk) {
//         return function (cream) {
//             return function (butter) {
//                 //compute all args which was passed 
//                 return `Cake is made with ${sugar} ${milk} ${cream} ${butter}`
//             }
//         }
//     }
// }

const makeCake = sugar => milk => cream => butter => `Cake is made with ${sugar} ${milk} ${cream} ${butter}`

const cake = makeCake('sugar')('milk')('cream')('butter')
console.log(cake)
....................................................................................
			var vs let and const



console.log(a)

var a = 10
//the variable is declared after declaration and initalization
console.log(a);

console.log(b)

here a is declarated before access, but js gives an output "undefined"..

undefined means the variable declared but no value is assigned


javascript code 

https://v8.dev/docs/ignition

1.source code
 index.js ---->parser---> parsed code(string lexical tree)-->compiler---ByteCode(assembly)


console.log(a)

var a = 10
//the variable is declared after declaration and initalization
console.log(a);

console.log(b)

2.parsed code
index.js

var a;
console.log(a)
a = 10
//the variable is declared after declaration and initalization
console.log(a);

let hai; //undefined

hai() ---runtime error

hai = function(){
    console.log('hai')
}


3.compiled code

//source code 
console.log('a before declaration', a)

//console.log(b)

var a = 10
//the variable is declared after declaration and initalization
console.log('after a', a);

let b = 100

console.log(b)

//parsed code:

//pushing variable declaration at top level is called "Hositing"
// var a;
// console.log(a)
// a = 10
// //the variable is declared after declaration and initalization
// console.log(a);

/**
 * Compile time 
 *    -parsing time 
 *        -code rearrangement happens
 *               -hositing
 * Runtime /execution time 
 *       -assembly code 
 */
/////////////////////////////////////////////////////////////////////////////////////

//this works fine 
sayHello()

function sayHello(){
    console.log('Hello')
}
sayHello()

hai()

var hai = function(){
    console.log('hai')
}
hai()
...................................................................................

functions and hositing:
//hositing inside function code 

/**any variables declared inside function also will be hosited inside function : function hositing */
function add() {
    console.log(a)
    var a = 10;
    var b = 20;
    var c = a + b
    console.log(a)
}
add()
............
block scope:
   the life of variable is available within {} which is called block scope.

function login(userName, password) {

    console.log(foo)
    if (userName === 'admin' && password === 'admin') {
        var foo = 'bar'
        console.log('login success')
    }
    console.log(foo)
}
login('admin','admin')

undefined
index.js:7 login success
index.js:9 bar

here also variable called foo is hoisted at function level, so js does not have blocking scope directly.

What if i want block scope?

ES 5:
   Immediate-Invoked Function Expression (IIFE)

//Immediate-Invoked Function Expression (IIFE)
/**
 * 1.anonmous function - 
 * 2.gets invoked automatically.
 * 3.In jquery
 */

var status = (function (lib) {
    console.log('app', lib)
    return 'done'
})('jQuery')
console.log(status)



function login(userName, password) {
    //console.log(foo)
    if (userName === 'admin' && password === 'admin') {
        (function () {
            var foo = 'bar'
            console.log('login success')
        })()
    }
    console.log(foo)
}
login('admin', 'admin')

ES 6 introduced new keyword which does not leak the scope- perserves the block scope-let and const


// function login(userName, password) {
//     //console.log(foo)
//     if (userName === 'admin' && password === 'admin') {
//         (function () {
//             var foo = 'bar'
//             console.log('login success')
//         })()
//     }
//     console.log(foo)
// }
function login(userName, password) {
        //console.log(foo)
        if (userName === 'admin' && password === 'admin') {
            // (function () {
            //     var foo = 'bar'
            //     console.log('login success')
            // })()
            let foo = 'bar'
            console.log('login success',foo)
        }
        console.log(foo)
    }
login('admin', 'admin')
.....................................................................................
				 Objects and javascript

According to ecma script spec, js is "object based langugage"

Object orientation vs Object based language:
............................................

Javascript is not strongly typed language.rather weakly typed/dynamic typed

int a=90;
a =true
compile time error.

Data types are verfied against variable during compile time.


var|let a=90;
a =true
here compile

For OO , we need strong typing, then only we can implement 100% oo, since js is weakly type which has implemented less and particial features only.
  if a language implements particial oo feature, which is called object based language.

oop
 ->Abstraction
      classes
 ->Encaspulation
       private,public
 ->Modularity
     
 ->Hierachy
    has-a, is-a
 ->Typing :strong typing
     -polymorphism
--------------------
 ->Concurrency
         Multi threading
 ->Persistency
        orm,storage

Implementation:

Object?
  Which represents an noun(person,entity...)

Object characteristics

1.state - properties
2.behahiour - actions which change/update property
3.identity  - to identify object uniquly from other objec

Object in program:

=>memory representation
=>collection of variables and methods - binding variables(state) and methods(behaviours)

state:
 instance variables
methods
 instance methods

How to create objects in javascript?

There are patterns

1.constructor pattern
  1.1.functions
  1.2.classes
2.literal pattern
3.factory pattern


//functions 
/**
 * 
 * functions having logic starts verb or verb+Noun
 *   eg add, addNumbers(),calculateInterest
 * functions are treated as class like java and c++, functions names must be noun
 *  eg: Employee,CreditCard,OrderService
 *    
 */

function add() {
    return 10 + 10
}
console.log(add())

function Employee() {
    //state : instance variables
    this.id = 1
    this.name = 'Subramanian'
    //behaviour:methods
    this.calculate = function () {
        return 100
    }
}
//new is keyword,
//Employee()-function call/constructor call
//emp is just variable, holding the memory address of object
//emp is reference variable
let emp = new Employee()

//how to access object properties(state,behaviour)
//. operator or [] operator
console.log(`Id ${emp.id}`)
console.log(`Name : ${emp.name}`)
console.log(`Calculate : ${emp.calculate()}`)

console.log(`Id ${emp['id']}`)
console.log(`Name : ${emp['name']}`)
console.log(`Calculate : ${emp.calculate()}`)


What is internal structure of object?

C++ decendants language object structure and js object structure is completly different
Every js object is hashtable/dictionary/map- key -value

key is string
value is any literal

Why js objects map?

  js language is highly dynamic
 during runtime objects can be modified

This process is called as "Object augmentation"

Add,update,delete,iterate object properties....


function Employee() {
    //single variable
    this.id = 1;
}
let emp = new Employee();
console.dir(emp)
//add new property
emp.name ='Subramanian'
console.dir(emp)
//update existing property
// if prop exits update, else add.
emp.name = 'Ram'
emp.city ='Coimbatore'
emp.state ='Tamil Nadu'
console.dir(emp)
//delete existing property
delete emp.state
//iterate :
//loop - object loop
for (const key in emp) {
    //[] operator is used to get object keys
   console.log(key,emp[key])
}


add()
new add()



//es 6 classes 

class Employee {
    //state : instance variables
    id = 1
    name = 'Subramanian'
    //behaviour:methods
    calculate() {
        return 100
    }
}
//object creation syntax
let emp = new Employee()
console.log(`id ${emp.id} ${emp.name} ${emp.calculate()}`)


constructors :
//state init using constructors

function Employee(id = 0) {
    this.id = id // hardcoded state 
}

//Employee() - this is constructor call
let emp = new Employee(1) //constructor parameters
console.log(emp)


class Customer {
    //id// hardcoded state
    constructor(id = 0, name = '', city = '') {
        this.id = id
        this.name = name
        this.city = city
    }
}
//Customer() is constructor call
let customer = new Customer()
console.log(customer)


Hoisting and classes:

let customer = new Customer()
console.log(customer)
function Customer (){

}

//var emp1 = new Employee()

class Employee {
    constructor(id=0){
        this.id =id;
    }
}
let emp = new Employee()


function declarations and class declarations is differ from "Hoisting".
 function can be hoisted where as classes not.


Class Expressions:
 classes can be assigned to a variables.

//class expression

let Rectangle = class {
    constructor(height, width) {
        this.height = height;
        this.width = width
    }
}
let rect = new Rectangle(10,10)
console.log(rect)

Why: every class is a function.


let Rectangle = class {
    constructor(height, width) {
        this.height = height;
        this.width = width
    }
}
let rect = new Rectangle(10,10)
console.log(rect)

console.log(typeof Rectangle) //Function.

static keyword in es 6 :


//variable types: instance variables,static variables
//instance variables are accessed with help of "reference" where as static variables are accessed with "className.variableName"


class Message {
    static WARNING = 'Warning'
    static ERROR = 'error'
    static SUCCESS = 'success'
   
}
console.log(Message.WARNING)

class Factory {
    //static methods 
    static getInstance(){
        return new Factory();
    }    
}
let factory = Factory.getInstance()
console.log(factory)
////////////////////////////////////////////////////////////////////////////////////

getters in classes:
 
In javascript, when you access property, interally it calls implicit get method.

emp.id ----> emp.getId

//gridTemplateRows: 


class Reactangle {
    constructor(height = 0, width = 0) {
        this.height = height
        this.width = width
    }
    //getter property
    get area(){
        return this.calcArea()
    }

    //biz methods
    calcArea(){
        return this.height * this.width
    }
}
let rct = new Reactangle(10,10)
// console.log(rct.calcArea())
console.log(rct.area)
.....................................................................................
			  Literal Objects
.....................................................................................

Objects are created without constructors(fun/class).
//literal objects 
/**
 *   object defintion(properties and its value) are enclosed with {}
 * 
 *  syntax:
 * let variable=  {
 *    key:value, 
 *    key:value
 *  }
 * key is variable
 * value is literal
 * literal can be any thing - nu/str/bool/unde,null,function,object,NaN
 * type of literal is based on type of value
 * 
 * what is type of key?
 *   the type of key always "string".
 * type of key not need to explicity declared with "",''
 * Can i declare with  in double quotes/single qutoes 
 *    Yes
 */

let emp = {
    id: 1,
    name: 'Subramanian',
    status: true
}
console.log(emp)
//keys are strings-valid
let user = {
    "id": 1,
    "name": 'Subramanian',
    "status": true,
    'city': 'Coimbatore'
}
console.log(user)

//how to introduce functions inside literal object : methods

let component = {
    init: function () {
        return 'init'
    }
}
console.log(component.init())

//arrow function
component = {
    init: () => 'init'
}
console.log(component.init())

//e6 class method syntax
component = {
    init() {
        return 'init'
    },
    destroy() {
        return 'destroy'
    },
    fetch() {
        return 'fetch'
    }
}
console.log(component.init(),component.destroy(),component.fetch())

//nested objects 
let user = {
    id: 1,
    name: 'Subramanian',
    //nested
    address: {
        city: 'Coimbatore'
    },
    location: {
        geo: {
            lat: 10.89,
            lng: 90.89
        }
    }
}
console.log(user.id)
console.log(user.name)
console.log(user.address.city)
console.log(user.location.geo.lat)
console.log(user.location.geo.lng)




// function printUserDetails(user) {
//     console.log(`Id ${user.id}`)
//     console.log(`Name ${user.name}`)
//     console.log(`City ${user.address.city}`)
//     console.log(`Lat ${user.location.geo.lat}`)
//     console.log(`Lng ${user.location.geo.lng}`)
// }
//Object Destructuring : breaking object properties into local variables

// function printUserDetails(user) {
//     //Destructure : unpacking varibles from the object 
//     const { id, name, address, location } = user
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${address.city}`)
//     console.log(`Lat ${location.geo.lat}`)
//     console.log(`Lng ${location.geo.lng}`)
// }
//destructure nested properties
// function printUserDetails(user) {
//     //Destructure : unpacking varibles from the object 
//     const { id, name, address: { city }, location: { geo: { lat, lng } } } = user
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${city}`)
//     console.log(`Lat ${lat}`)
//     console.log(`Lng ${lng}`)
// }

//destructuring inside func arg.
// function printUserDetails({ id, name, address: { city }, location: { geo: { lat, lng } } }) {
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`City ${city}`)
//     console.log(`Lat ${lat}`)
//     console.log(`Lng ${lng}`)
// }

//destructuring with arrow functions
const printUserDetails = ({ id, name, address: { city }, location: { geo: { lat, lng } } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`City ${city}`)
    console.log(`Lat ${lat}`)
    console.log(`Lng ${lng}`)
}
//values are passed to the function in two ways
//1.hardcoded 2.variables
let user = {
    id: 1,
    name: 'Subramanian',
    //nested
    address: {
        city: 'Coimbatore'
    },
    location: {
        geo: {
            lat: 10.89,
            lng: 90.89
        }
    }
}
printUserDetails(user)

//hardcoded values
printUserDetails({
    id: 1,
    name: 'Subramanian',
    //nested
    address: {
        city: 'Coimbatore'
    },
    location: {
        geo: {
            lat: 10.89,
            lng: 90.89
        }
    }
})
....................................................................................

//how to return object from the function and how to apply destructuring.

// function getUserDetails() {
//     let user = {
//         id: 1,
//         name: 'Subramanian',
//         //nested
//         address: {
//             city: 'Coimbatore'
//         },
//         location: {
//             geo: {
//                 lat: 10.89,
//                 lng: 90.89
//             }
//         }
//     }
//     return user ;
// }

// function getUserDetails() {
//     //here we return hardcoded values
//     //how to return dynamic objects with values
//     return {
//         id: 1,
//         name: 'Subramanian',
//         //nested
//         address: {
//             city: 'Coimbatore'
//         },
//         location: {
//             geo: {
//                 lat: 10.89,
//                 lng: 90.89
//             }
//         }
//     }
// }

//how to return dynamic properties
// function getUserDetails(id = 1, name = 'Subramanian', city = 'Coimbatore', lat = 1.0, lng = 90.0) {
//     return {
//         id: id,
//         name: name,
//         //nested
//         address: {
//             city: city
//         },
//         location: {
//             geo: {
//                 lat: lat,
//                 lng: lng
//             }
//         }
//     }
// }


// function getUserDetails(id = 1, name = 'Subramanian', city = 'Coimbatore', lat = 1.0, lng = 90.0) {

//     //if key:value ,leftSide:rightSide is same,return only one 
//     return {
//         id,
//         name,
//         //nested
//         address: {
//             city
//         },
//         location: {
//             geo: {
//                 lat,
//                 lng
//             }
//         }
//     }
// }

//arrow functions and object return
const getUserDetails = (id = 1, name = 'Subramanian', city = 'Coimbatore', lat = 1.0, lng = 90.0) => ({
    id,
    name,
    //nested
    address: {
        city
    },
    location: {
        geo: {
            lat,
            lng
        }
    }
})


console.log(getUserDetails())
console.log(getUserDetails(2, 'Ram', 'Chennai'))
....................................................................................
				classes and destructuring



class Reactangle {
    constructor(height = 0, width = 0) {
        this.height = height
        this.width = width
    }
    //biz methods
    // calcArea() {
    //     console.log('height func',this.height)
    //     return this.height
    // }
    calcArea = () => {
        console.log('height func', this.height)
        return this.height
    }
}
// let rct = new Reactangle(10,10)
// console.log(rct.width)
// console.log(rct.height)
// console.log(rct.calcArea())
let { width, height, calcArea } = new Reactangle(10, 10)

let rect = new Reactangle(10, 10)

console.log('width', width)
console.log('height', height)
console.log('area', rect.calcArea())
console.log('area', calcArea())
.....................................................................................
			Hierachy - How to share code 

1.HAS-A -Composition
    
//has -a 

class Address {
    constructor(city = '', state = '', zipcode = '') {
        this.city = city
        this.state = state
        this.zipcode = zipcode
    }
}

class Employee {
    constructor(id = 0, name = '', address = new Address()) {
        this.id = id
        this.name = name
        //has-a
        this.address = address
    }
}
let emp = new Employee()
console.log(emp)

emp = new Employee(12, 'subramanian', new Address('coimbatore', 'TN', '00000'))
console.log(emp)

//has -a in literals

let customer = {
    id: 1,
    name: 'John',
    //has-a
    address: {
        city: 'coimbatore',
        state: 'TN'
    }
}

console.log(customer)




2.IS-A - inheritance
   Javascript inhiertance is little confused when compare to javac/c++ as it is dynamic and does not have static types.

In c++/java, inheritance is decided during compile time- class based
In js inheritance is decided during runtime - Object based.

Any object based inheritance, "Prototypical Inheritance"

Prototype: 
   A prototype is a delegation object used to implement prototype-based inheritance.


Object Creations:
 -Constructors
 -literals
 An object is a collection of properties, and has a single prototype object. The prototype may be either an object or the null value.


Letâ€™s take a basic example of an object. A prototype of an object is referenced by the internal [[Prototype]] property, which to user-level code is exposed via the __proto__ property.


Employee {id: 1}
id
: 
1
[[Prototype]]
: 
Object
constructor
: 
Æ’ Employee()
[[Prototype]]
: 
Object
constructor
: 
Æ’ Object()
hasOwnProperty
: 
Æ’ hasOwnProperty()
isPrototypeOf
: 
Æ’ isPrototypeOf()
propertyIsEnumerable
: 
Æ’ propertyIsEnumerable()
toLocaleString
: 
Æ’ toLocaleString()
toString
: 
Æ’ toString()
valueOf
: 
Æ’ valueOf()
__defineGetter__
: 
Æ’ __defineGetter__()
__defineSetter__
: 
Æ’ __defineSetter__()
__lookupGetter__
: 
Æ’ __lookupGetter__()
__lookupSetter__
: 
Æ’ __lookupSetter__()
__proto__
: 
(...)
get __proto__
: 
Æ’ __proto__()
set __proto__
: 
Æ’ __proto__()

By default Any Object if you create using constructors(fun/class) will have "Prototype Object as direct Parent" Which intern connects "Object" which is super object

Employee----->ProtoType---->Object----->null

By default Any Object if you create using literals will not have "Prototype Object as direct Parent" which directly connects "Object" which is super object


customer----->---->Object----->null
....................................................................................
                        inheritance and property lookup.

In java

source code
class A {
  int a
}
class B extends A{
  int b
}

compiled code
class A {
  int a
}
class B extends A{
  int a
  int b
}

b.a 
b.b
.............
In js , properties are not copied when you access properties, rather which uses a concept call lookup.


class Employee {
    constructor(){
        this.id =1;
    }
}
let emp =new Employee()
console.log(emp.id)

here the runtime first will check in current object, if it is found, then it will return other it will lookup its parent if not again its lookup its parent so on until property match found...
if no match found, it returns undefined.

emp----|Employee--->Parent---->Parent----Object---No--undefined


How to add Properties in the "ProtoType" Object?
How to access Prototype Object?
How to augment prototype Object?

class Employee {
    constructor() {
        this.id = 1;
    }
}

//add/Augment property in the Prototype Object 
Employee.prototype.name = 'Subramanian'
//Add property in the Object 
Object.prototype.grade = 'Senior Manager'

let emp = new Employee()
//update the property
emp.id = 900;
emp.name ='Ram'

console.log(emp)
console.log(emp.id)
console.log(emp.name)
console.log(emp.grade)

let emp1 = new Employee()

console.log(emp1)
console.log(emp1.name)

let emp2 = new Employee()

console.log(emp2)
console.log(emp2.name)
............................*************..........................................
			What if i dont want "Prototype" as immediate Parent, I want to have my own parent.

Employee ---->Prototype--->Object---|null

Employee---->Person----Prototype--->Object---|null

//this  - implicit pointer, which is declared by js runtime and initalized to current instance memory location
//super  -  implicit pointer which is delclared by js runtime and initalized to parent instance memory location

class Person {
    constructor(firstName = '', lastName = '') {
        this.firstName = firstName
        this.lastName = lastName
    }
}
Person.prototype.name = function () {
    return `${this.firstName} ${this.lastName}`
}
class Employee extends Person {
    constructor(id, firstName, lastName) {
        super(firstName, lastName)
        this.id = id
    }
}
let emp = new Employee(10, 'Subramanian', 'Murugan')
console.log(emp.name())

class Customer extends Person {
    constructor(id, firstName, lastName) {
        super(firstName, lastName)
        this.id = id
    }
}
let customer = new Customer(140, 'Subramanian', 'Shirisha')
console.log(customer.name())
.....................................................................................

Built in java  scripts:

1.POJO - Plain old java objects

2.DOM - Document object model - user interface.

POJO:
1.Object 
 Object is super most parent object.... without which we cant create any object.

Object.assign:
  in order to create immutable object, we can use Object.assign method.

Immutablity And Pure function
.............................

//Functional Programming Principle : pure function 

/**
 * Pure function:
 *  1.A function is pure if function does not modify the input parameters  and also it should not do side effects.
 * 2.if a function wants to modify the input parameters, it should return immuable object. 
 */

//Rule 1:
//side effect: if function does io operation, mutations on parameters - side effects
//if any function does side effects - impure function.

//pure function
function calculate(a) {
    return a;
}
console.log(calculate(10))

function TaskBar(props) {
    return props
}
TaskBar({ title: 'Google Pages' })
/////////////////////////////////////////////////////////////////////////////////////
//Pure function rule 2:

//How to make this function pure, -> return immutable object .

//in order to make any function pure, we need to return immutable object.
//Ways
//1. return plain java script


// function updateProfile(profile, city) {
//     //update city;
//     profile.city = city;
//     return profile;
// }

// function updateProfile(profile, city) {
//     //return new Object by copying old object properties
//     return {
//         id: profile.id,
//         name: profile.name,
//         city: city
//     }
// }

//way 2: Object.assign

// function updateProfile(profile, city) {
//     //return new Object by copying old object properties
//     return Object.assign({}, profile, { city: city })
// }
//way 3: using es 7 spread Operator.

// function updateProfile(profile, city) {
//     //return new Object by copying old object properties
//     return { ...profile, city: city }
// }
const updateProfile = (profile, city) => ({ ...profile, city })

let profile = {
    id: 1,
    name: 'subramanian',
    city: 'chennai'
}
console.log('before update ', profile)
const result = updateProfile(profile, 'coimbatore')
console.log('After update', result)
console.log(profile === result ? 'Same Object' : 'Different Object')
.....................................................................................

Object properties can be changed during runtime-Augmentation is always possible.

Can we control object modification?

Yes, With help of Object.freeze method.
//Object augmentation and how to avoid that.

const { log } = console;

let profile = {
    id: 1,
    name: 'Subramanian'
}
Object.freeze(profile)
log('Before Update Profile',profile)
profile.city = 'Coimbatore'
log('After Update Profile',profile)
profile.name = 'Ram'
log('After Update Profile',profile)
delete profile.name
log('After Update Profile',profile)



const object1 = {};

Object.defineProperties(object1, {
  property1: {
    value: 42,
    writable: true
  },
  property2: {}
});
...............................................................................
				Wrapper Objects
................................................................................

every primitive has equ Wrapper
number --- Number
//Numbers

let a = 100 //Number
let b = Number(20)
console.log(a, b)

console.log(Number.MAX_VALUE)

let x = 10
let y

let z = x * y;
if (Number.isNaN(z)) {
    console.log('Number is NaN')
} else {
    console.log('Number is not NaN')
}
//Number instance
//constructor pattern

let mynum = new Number(100.89434)
console.log(mynum.toFixed(2))
//literal pattern
let price = 3445.343434343
console.log(price.toFixed(2))
console.log(1212.44545.toFixed(3))


String Object:
//strings
let name = 'hello'
let city = new String('coimbatore')


const sentence = 'The quick brown fox jumps over the lazy dog.';

const word = 'fox';

console.log(`The word "${word}" ${sentence.includes(word) ? 'is' : 'is not'} in the sentence`);
// expected output: "The word "fox" is in the sentence"
.....................................................................................

Array Object:

pure functions
map => new 
filter =>
concat 
.....

//pattern
// constructor pattern
//new Array()
//literal pattern
// []

let list = new Array(1, 2);
console.log(list)
let mylist = [1, 2, 34, 578]
console.log(mylist)

const doubleIt = item => item * 2
mylist.map(doubleIt).forEach(item => console.log(item))
..................................................................................
				Non Blocking and async programming

1.callbacks
2.callback hell
3.Promises
4.Async await

 Using api like timers,ajax api(XHR),fetch api,websockets,dom events

......

Program executes seq:

--|
--|--takes more time
--waiting
--
  |
  |
thread
  |     
 Runtime - jvm/clr..

..................................................................................
      Internal Arch of blocking and Non blocking Programming style
...................................................................................


Java IO:
 FileInputStream fns = new FileInputStream("c:/temp/mytemp.txt")

 fns.read()---java high level api to read single byte.

 fns.read()-java api
   |
 java api layer- jni
   |  
  read() -jni api - written in c language
   |
  os layer---Linux/win/mac
   |
  read() -  os system call - written in c language
   |
Kernal Space   
   |
 File Descriptor

.....................................................................................
				 File Descriptors
.....................................................................................

1.File descriptors is simple array(ds),written in c language.
2.File descriptor is associated with every process on os- if you run more than one process - will have more file descriptor table

 jvm---------> fd 
 browser-----> fd
 notepad ---> fd

fd is created when process is created, destroyed when process is destroyed...

FD arch:
Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

These values are standard which cant be altered.

..

Network io and web server:

Any web server if you take, it works based on io model- socket-network io.

Traditional web server, for every client request is  handled inside server by a thread.

                    "Request Per Thread model"


Non blocking apis were introduced in Linux  , in 2000.

select - first linux api introduced to make non blocking calls.

 Program
  readByte ----->select----|kernalspace---make entry-
                 <---control is returned immediately to the caller|
.....................................................................................

Event Loop:
  It is while loop watching kernal fd table for data readnes
Event Loop thread:
  It is a thread listening for events which emitted by kernal.
Callback/Listener
   It is a function which has been registered for event notification.
....................................................................................
			How to implement/write non blocking/async programming

Requirement:
1.we need high level js api to initiate non blocking calls
apis:
 in browser
 -timers - setTimeout,setInterval
 -ajax api - XMLHTTPREQUEST api
 -websocket api
 -dom apis
2.Listeners

Styles:
1.callback style
2.Promise style
3.async...await style....

1.callback style:
 function is passed as parameter to another-hof, which is registered for handling results because of delayed calls....
  
//non blocking using timer.

function blockMe(message) {
    console.log(message)
}
function connect(callback) {
    //js non blocking api : setTimeout 
    // callback()
    setTimeout(callback, 5000, 'delayed response')
}
blockMe('hello')
connect(function (response) {
    console.log('connect',response)
})
blockMe('hai')
....................................................................................
			  callback chaining /Callback nesting
...................................................................................

The output of one callback will be input to the another callback.
//callback chaining

const getUser = (resolve, reject) => {
    let user = {
        name: 'admin',
        password: 'admin'
    }
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, { err: 'User not found' })
    }
}
//the out put of getUser will be input to the login
const login = (user, resolve, reject) => {
    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    } else {
        setTimeout(reject, 1000, { err: 'login failed' })
    }
}

//the out put login will be input to the dashboard function 
const showdashboard = (status, resolve, reject) => {
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'admin page')
    } else {
        setTimeout(reject, 1000, { err: 'user page' })
    }
}


getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showdashboard(status, page => {
            console.log(page)
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})
...................................................................................
				Callback Hell
...................................................................................

getUser(user => {
    console.log(user)
    login(user, status => {
        console.log(status)
        showdashboard(status, page => {
            console.log(page)
        }, err => {
            console.log(err)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No.
                     	 "Callback Hell"
.............................................................................................

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".
.....................................................................................

How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks				

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.


Promise Object:

   Essentially, a promise is a returned object to which you attach callbacks, instead of passing callbacks into a function.
  Promise Object by default async, which means they have implemented timer with 0 ms by default.

Promise Object Creation Patterns
................................

1.Factory pattern
2.Constructor Pattern

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

//Promise Object by factory pattern

function blockMe(message) {
    console.log(message)
}
function delay() {
    return Promise.resolve('Success')
}

blockMe('hello')
delay()
  .then(response => console.log(response))
blockMe('hai')

errors only:
//Promise Object by factory pattern

function blockMe(message) {
    console.log(message)
}
function delay() {
    return Promise.reject('something went wrong')
}

blockMe('hello')
delay()
  .catch(err=>console.log(err))
blockMe('hai')
..............
Success and error
//how to show success and reject 

function login(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    } else {
        return Promise.reject('Login failed')
    }
}
login('admin', 'admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

login('foo', 'foo')
    .then(status => console.log(status))
    .catch(err => console.log(err))
.................................................................................

Constructor Pattern.

//how to show success and reject 

function login(userName, password) {
    //constructor pattern
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 5000, 'Login success')
        } else {
            setTimeout(reject, 5000, 'Login Failed')
        }
    })
}
login('admin', 'admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

login('foo', 'foo')
    .then(status => console.log(status))
    .catch(err => console.log(err))
.....................................................................................
Promise Chaining:
//callback chaining
const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin',
            password: 'admin'
        }
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User not found' })
        }
    })
}
//the out put of getUser will be input to the login
const login = user => {
    console.log('login is called')

    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, { err: 'login failed' })
        }
    })
}

//the out put login will be input to the dashboard function 
const showdashboard = status => {
    console.log('showDashBoard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'admin page')
        } else {
            setTimeout(reject, 1000, { err: 'user page' })
        }
    })
}

//callback hell code 
// getUser(user => {
//     console.log(user)
//     login(user, status => {
//         console.log(status)
//         showdashboard(status, page => {
//             console.log(page)
//         }, err => {
//             console.log(err)
//         })
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })

//promise chaining
// getUser()
//     .then(user => {
//         login(user).then(status => {
//             showdashboard(status)
//                 .then(page => console.log(page)).catch(err => {
//                     console.log(err)
//                 })
//         }).catch(err => {
//             console.log(err)
//         });
//     })
//     .catch(err => {
//         console.log(err)
// })
//syntax simplification
// getUser()
//     .then(user => {
//         return login(user)
//     })
//     .then(status => {
//         return showdashboard(status)
//     })
//     .then(page => {
//         console.log(page)
//     })
//     .catch(err => {
//         console.log(err)
//     })
// getUser()
//     .then(user => login(user))
//     .then(status => showdashboard(status))
//     .then(page => console.log(page))
//     .catch(err => console.log(err))

//using destrusturing syntax
//if there is single arg and passed into the function : we can remove args 
//method reference syntax 
const { log } = console;
getUser()
    .then(login)
    .then(showdashboard)
    .then(log)
    .catch(log)
....................................................................................
			Thenables

If promise is going to be chained more, you can see lot of thens, how to avoid thens

async...await keywords- es 7 feature

async:
 async is keyword used infront of functions- async functions.
 async function by default return promises


//async function 

async function getValue(){
    return 10 //Promise.resolve(10)
}
//console.log(getValue())
getValue().then(res=>console.log(res))

................................................................................
async and await keywords

inside async functions  you can resolve and reject promises without then and catch method.

function login(userName, password) {
    //constructor pattern
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 100, 'Login success')
        } else {
            setTimeout(reject, 100, 'Login Failed')
        }
    })
}

async function main() {
    // login('admin', 'admin')
    // .then(status => console.log(status))
    // .catch(err => console.log(err))
    try {
        const status = await login('admin', 'admin')
        console.log(status)
    }
    catch (err) {
        console.log(err)
    }
}
main();
....
//callback chaining
const getUser = () => {
    console.log('getUser is called')
    return new Promise((resolve, reject) => {
        let user = {
            name: 'admin',
            password: 'admin'
        }
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User not found' })
        }
    })
}
//the out put of getUser will be input to the login
const login = user => {
    console.log('login is called')

    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, { err: 'login failed' })
        }
    })
}

//the out put login will be input to the dashboard function 
const showdashboard = status => {
    console.log('showDashBoard is called')
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'admin page')
        } else {
            setTimeout(reject, 1000, { err: 'user page' })
        }
    })
}

// const { log } = console;
// getUser()
//     .then(login)
//     .then(showdashboard)
//     .then(log)
//     .catch(log)

async function main() {
    try {
        const user = await getUser();
        const status = await login(user)
        const page = await showdashboard(status)
        console.log(page)
    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
				Ajax Calls
....................................................................................
Using xhr:
function fetch(method, url) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open(method, url);
        xhr.onload = function () {
            if (this.status >= 200 && this.status < 300) {
                resolve(xhr.response);
            } else {
                reject({
                    status: this.status,
                    statusText: xhr.statusText
                });
            }
        };
        xhr.onerror = function () {
            reject({
                status: this.status,
                statusText: xhr.statusText
            });
        };
        xhr.send();
    });
}

async function main() {
    // fetch('GET', 'https://jsonplaceholder.typicode.com/posts')
    // .then(function (posts) {
    //     console.log(posts);
    // })
    // .catch(function (err) {
    //     console.error('Augh, there was an error!', err.statusText);
    // });
    try {
        const posts = await fetch('GET', 'https://jsonplaceholder.typicode.com/posts')
        console.log(posts)
    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
				XHR calls using libs and frameworks
....................................................................................

fetch api or fetch.js from the google. now it is added inside browser.
if you want to target old browsers, you have to use poly fills

fetch is abstraction on xhr, which is powered by promises by default


function getPosts() {
    return fetch('https://jsonplaceholder.typicode.com/posts')
}

async function main() {
    try {
        // const response = await getPosts()
        // const posts = await response.json()
        // console.log(posts)
        const posts = await (await getPosts()).json()
        console.log(posts)

    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
			Scope Chain - Static and Dynamic Programming
....................................................................................
Static and dynamic programming:
..............................

static means parsing time expression binding

dynamic means runtime epxression binding.

expression ; collection of variables and its binding.

eg:
 var a =10; // expression

scope;
 Visitbility of variables.
 Where it is visible

Where means: The place where we have declared variables. 

variable declaration places;

1.inside script file.
2.inside function
3.function args.

es 6:
1.inside class
2.inside script -modules


"When visibility of a variable is activated"?

Phases:
 - Parsing phase
 - Execution/ run time phase

Types of scopes:

1.static scope / lexical scope
2.dynamic scope - runtime 
3.augmented scope - deprecated in js now a days.

1.static scope:

A langauge implements static scope, if only by looking at the source code one can determine in which environment a binding is resolved.

How to implement lexical scope/ static scope?

//static scope.

var a = 10;

function print_a() {
    console.log(`print_a function ${a}`);
}

function run() {
    var a = 100;
    console.log(`run method ${a}`);
    print_a()
}
run();

variable "a" for print_a function is free,since it's neither a parameter , nor a local variable of this function.

The  variable "a'  is captured / bound / attached to print_a function ?

 "during print_a function is created / initalized"

 -lexcial scope / static scope.


var a = 10;

function fun1() {

    console.log(`fun1 ${a}`);

    function fun2() {
        var a = 8;
        console.log(`fun2 ${a}`);

        function fun3() {
            // var a = 8;
            console.log(`fun3 ${a}`);

        }
        fun3()
    }
    fun2();

}
fun1()

Variable binding resolution or scope chain:
...........................................

Lexical environment: 
  A lexical environment is a structure used to define association between identifiers(variables) appearing in the context with their values. 

Each environment can have a reference to an optional parent environment.

So an environment is a storage of variables, functions, and classes defined in a scope.

Types of env:

1.Global Environment
2.function environment

Each environment is data structure- Hash table/Dictionary : key-value pair

-key :
Record:Value
Parent:Value

Value of Record would be another dictionary
value of Parent is "pointer to another env"

What record can have?
Information about that env, storage information.

Globlal Environment is env which hold other envs : Global Context


let x = 10;
let y = 20;
 
function foo(z) {
  let x = 100;
  return x + y + z;
}
 
foo(30); // 150

Look up theory:

when a variable is accessed by a function.

-It is looks in the current "Environment Record", if not present it will look its parent and so until global env. if not present any where , it will throw error -"not defined"



//inside script
var x = 10;
var y = 20;

function foo(z) {
    //inside function
    let x = 100;
    return x + y + z;
}

let r = foo(30); // 150
console.log(r);

var a = 10;

function fun1() {

    console.log(`fun1 ${a}`);

    function fun2() {
        var a = 88888;

        console.log(`fun2 ${a}`);

        function fun3() {
            console.log(`fun3 ${a}`);
        }
        fun3()
    }
    fun2();

}
fun1()
.....................................................................................
Dynamic binding:

Dynamic scope:

  if langage implements dynamic scope, if a "Caller" who is calling function defines an activation environment of a "callee"


caller  - object
callee - function

How to implement dynamic scope?

  "with help of this keyword"


this:
   this is reference variable , which is implicit.
   the value of "this" variable is determined and provided by exactly by the caller

 eg:
   var | let |const a =10 ;

   this = ?

Note:
  the value of "this" may be changed in javascript during runtime using mode
  
mode:
  1.strict 
  2.non-strict

Demo to know the value of "this"


//Know the value of "this"

function sayHello(){
    return this  // value of this, will be dermined by the function caller scope .
}
console.log(sayHello())


if you run this in browser, the result would be "Window"

Window is object in browser .

By default , any function is declared inside script,that function belongs to window object

"the value of this , will determine that function belongs to whom.

function fun1() {
    console.log('fun1')
    function fun2() {
        console.log('fun 2')
        return this;
    }
    console.log(fun2())
    return this;
}
console.log(fun1())

"this keyword" just like other variables like a and b but its value always points the address of object.

  "this=objectaddress"

By default  in js functions are called within script belongs to window object.

..................................................................................
				strict mode
.................................................................................

You know very well js was developed and tested in 10 days. 
Javascript always has two areas
 -good parts
 -bad  parts

java script strict enables good parts.

"use strict"


"use strict"

function fun1() {
    console.log('fun1')
    function fun2() {
        console.log('fun 2')
        return this;
    }
    console.log(fun2())
    return this;
}
console.log(fun1())

in strict mode the value of "this would be" undefined, the owner of the function is not decided.
....................................................................................
How to bind function with object dynamically   or how to change the owner of function?

in js function itself is Object , called "Function Object"


Since function is object which has methods...

1.call
2.apply
3.bind

  "These methods are used to change the owner of function"

1.call
 The call() method calls the function with a given this value and arguments provided individually.

function sayHello(){
    console.log(this.message)
    return this;
}
//owner of sayHello here is window

message = 'Window message'

console.log(sayHello())

//change the owner of function .
let greetings = {
    message:'greetings message'
}
// sayHello.call(targetObject)
sayHello.call(greetings)
// console.log(sayHello())

let hi = {
    message:'Hi message'
}
sayHello.call(hi)
..................................................................................
			How to pass args to the function with call


function sayHello(name,message){
    console.log(this,name,message)
}
let greetings = {
    name:'greetings'
}
sayHello.call(greetings,'subramanian','hello')

let hai = {
    name:'ha'
}
sayHello.call(hai,'subramanian','hai')
....................................................................................

apply:
  apply(target,array)

apply and call is same but only second args are different,which is array.
function getStocks(args){
  console.log(this,args)
}
const google = {
    name:'google stock'
}
getStocks.apply(google,[{id:1,value:1222}])
.................................................................................
				bind

lazy invocation, when you call bind method, it wont execute rather it returns reference of that function which is executed later.

function onClick(response) {
    console.log(response,this.name)
}
const MyButton = {
    name: 'My Button'
}
const myListener = onClick.bind(MyButton)
//trigger this function later on 
// setTimeout(()=>myListener('Hello'),5000)
setTimeout(myListener,5000,'Hello')
.....................................................................................
				Lexcial and dynamic scope togther
.....................................................................................

//lexcical and dynamic scope 

const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
        //inner function 
        function learn(){
            console.log('learn function')
            console.log(this, this.name, 'is teaching')
        }
        learn() //called inside teach function 
    }
}
training.teach()

Points:
 1.when you call learn method, this bounds to global object in "non strict mode"-window

what if i want to access "name" property of training object inside learn method?

Solutions:

1.Using "self" semantic 
  self is not keyword but semantic variable

const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
       //local variable of teach will be accessiable inside learn
        let self = this
        function learn(){
            console.log('learn function')
            //console.log(this, this.name, 'is teaching')
            console.log(self, self.name, 'is teaching')
        }
        learn() //called inside teach function 
    }
}
training.teach()


2.Using training reference variable directly inside learn method 
  const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
        function learn(){
            console.log('learn function')
            //console.log(this, this.name, 'is teaching')
            // console.log(self, self.name, 'is teaching')
            console.log(training, training.name, 'is teaching')

        }
        learn() //called inside teach function 
    }
}
training.teach()


3.Using functions call,apply,bind method
//solution 3:
const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
        function learn(){
            console.log('learn function')
            //console.log(this, this.name, 'is teaching')
            // console.log(self, self.name, 'is teaching')
            console.log(this, this.name, 'is teaching')

        }
        //learn.call(training) 
        learn.call(this)
    }
}
training.teach()
.............................................................................
solution 4 : return the function and call later.

//solution 4 : return the function and call later..

const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
        return function (){
            console.log('learn function')
            //console.log(this, this.name, 'is teaching')
            // console.log(self, self.name, 'is teaching')
            console.log(this, this.name, 'is teaching')

        }
    }
}
 const learn = training.teach()
 learn.call(training)

Solution :
 without using function.call/apply/bind , how to attach function with object.

 call ,apply method decides owner of the function during runtime - dynamic binding
 -the value of "this" keyword is decided during runtime only when function is called
 on particular object.

 We have very advanced technique , through which we can decide the value of this during "lexical time/compile time" - arrow functions.

"Arrow functions are lexically scoped with this keyword both in strict and nonstrict mode".

//solution 5 : Arrow functions :lexcially scoped
const training = {
    name: 'subramanian',
    teach: function () {
        console.log('teach function', this, this.name)
        // const learn = () => {
        //     console.log('learn function')
        //     console.log(this, this.name, 'is teaching')
        // }
        // learn()
        return () => {
            console.log('learn function')
            console.log(this, this.name, 'is teaching')
            return this;
        }
    }
}
console.log(training.teach()())
.....................................................................................
			  Modularity,DOM programming,w3c best practices
.....................................................................................





 








































































  




































































































